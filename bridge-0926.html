<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Voice Chat</title>
  <style>
    :root{color-scheme:light dark;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    body{margin:0;background:#0f1115;color:#e5e7eb;display:flex;min-height:100vh;align-items:center;justify-content:center}
    #app{width:min(720px,92vw);background:#151922;border-radius:16px;padding:20px 20px 16px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{margin:0 0 12px;font-size:22px}
    #status{display:flex;align-items:center;gap:8px;margin-bottom:12px;font-weight:600}
    #indicator{font-size:18px}
    #chat{height:300px;overflow:auto;background:#0b0e14;border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px}
    .msg{padding:8px 10px;border-radius:10px;line-height:1.35;white-space:pre-wrap}
    .msg.user{background:#1f2937;align-self:flex-end}
    .msg.assistant{background:#0f172a;align-self:flex-start}
    #controls{display:flex;gap:8px;margin:12px 0 6px;flex-wrap:wrap}
    button{padding:10px 14px;border-radius:10px;border:0;background:#2563eb;color:white;font-weight:600;cursor:pointer}
    button.secondary{background:#334155}
    button:disabled{opacity:.5;cursor:not-allowed}
    #hint{font-size:12px;opacity:.7}
  </style>
</head>
<body>
  <div id="app">
    <h1>üéôÔ∏è Voice Chat</h1>
    <div id="status"><span id="indicator">‚ö™</span><span id="status-text">Idle</span></div>
    <div id="chat"></div>
    <div id="controls">
      <button id="startBtn">Start Conversation</button>
      <button id="stopBtn" class="secondary" disabled>Stop Conversation</button>
      <button id="playBtn" class="secondary" disabled>Play Last Reply</button>
      <button id="configBtn" class="secondary">Config</button>
    </div>
    <div id="hint">Mic permission required. Bridge server handles STT/LLM/TTS. <span id="build"></span></div>
  </div>

  <dialog id="configDialog">
    <form method="dialog" id="configForm" style="display:flex;flex-direction:column;gap:10px;min-width:320px">
      <h3 style="margin:0">Config</h3>
      <label>Session Key<input id="sessionKey" type="text" placeholder="voice-chat:main" style="width:100%"></label>
      <label>TTS Voice<input id="voice" type="text" placeholder="nova" style="width:100%"></label>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:4px">
        <button id="cancelConfig" type="button" class="secondary">Cancel</button>
        <button id="saveConfig" type="submit">Save</button>
      </div>
    </form>
  </dialog>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.22.0/dist/ort.wasm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.29/dist/bundle.min.js"></script>
  <script>
    (() => {
      const BUILD = '2026-02-03-0926';
      const $ = id => document.getElementById(id),
        statusText = $('status-text'),
        indicator = $('indicator'),
        chat = $('chat'),
        startBtn = $('startBtn'),
        stopBtn = $('stopBtn'),
        playBtn = $('playBtn'),
        configBtn = $('configBtn'),
        configDialog = $('configDialog'),
        configForm = $('configForm'),
        cancelConfig = $('cancelConfig');

      const buildEl = $('build');
      if (buildEl) buildEl.textContent = `build ${BUILD}`;
      if (!playBtn) console.warn('playBtn missing from DOM');

      const config = { sessionKey:'voice-chat:main', voice:'nova' };
      let status='stopped', running=false, busy=false, vadInstance=null, currentAssistantEl=null, currentAudio=null, lastReplyText='', lastReplyAudio=null, lastReplyAudioUrl=null, ttsLoading=false;
      const statusMap = { listening:['üü¢','Listening...'], recording:['üî¥','Recording...'], processing:['üü°','Processing...'], speaking:['üîµ','Speaking...'], error:['‚ö´','Error'], stopped:['‚èπÔ∏è','Stopped'] };

      const setStatus = (state, detail) => {
        status = state;
        const [icon, text] = statusMap[state] || ['‚ö™', state];
        indicator.textContent = icon;
        statusText.textContent = detail || text;
      };
      const addMessage = (role, text) => {
        const div = document.createElement('div');
        div.className = `msg ${role}`;
        div.textContent = `${role === 'user' ? 'You' : 'Clawd'}: ${text}`;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        return div;
      };
      const updateAssistant = (text) => {
        if (!currentAssistantEl) currentAssistantEl = addMessage('assistant', '');
        currentAssistantEl.textContent = `Clawd: ${text}`;
        chat.scrollTop = chat.scrollHeight;
      };

      const loadConfig = () => {
        const saved = localStorage.getItem('voice-chat-config');
        if (saved) Object.assign(config, JSON.parse(saved));
      };
      const saveConfig = () => localStorage.setItem('voice-chat-config', JSON.stringify(config));
      const fillConfigForm = () => {
        $('sessionKey').value = config.sessionKey || '';
        $('voice').value = config.voice || '';
      };
      const applyFormToConfig = () => {
        config.sessionKey = $('sessionKey').value.trim() || 'voice-chat:main';
        config.voice = $('voice').value.trim() || 'nova';
      };
      const ensureConfig = async (force=false) => {
        loadConfig();
        if (force || !config.sessionKey) {
          fillConfigForm();
          configDialog.showModal();
          return false;
        }
        return true;
      };

      const float32ToWav = (samples, sampleRate=16000) => {
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        const writeStr = (offset, str) => { for (let i=0; i<str.length; i++) view.setUint8(offset+i, str.charCodeAt(i)); };
        writeStr(0,'RIFF'); view.setUint32(4,36+samples.length*2,true); writeStr(8,'WAVE'); writeStr(12,'fmt ');
        view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,1,true); view.setUint32(24,sampleRate,true);
        view.setUint32(28,sampleRate*2,true); view.setUint16(32,2,true); view.setUint16(34,16,true); writeStr(36,'data');
        view.setUint32(40,samples.length*2,true);
        for (let i=0; i<samples.length; i++) { const s=Math.max(-1,Math.min(1,samples[i])); view.setInt16(44+i*2, s<0?s*0x8000:s*0x7fff, true); }
        return new Blob([buffer], {type:'audio/wav'});
      };

      const blobToBase64 = async (blob) => {
        const buf = await blob.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let binary = '';
        for (let i=0; i<bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
      };

      const transcribe = async (wavBlob) => {
        const audioBase64 = await blobToBase64(wavBlob);
        const response = await fetch('/api/transcribe', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ audioBase64, mimeType:'audio/wav' })
        });
        if (!response.ok) {
          const text = await response.text().catch(() => '');
          throw new Error(`Transcribe error ${response.status}: ${text || 'no body'}`);
        }
        let data;
        try {
          data = await response.json();
        } catch (err) {
          throw new Error(`Transcribe parse error: ${String(err)}`);
        }
        return data.text || '';
      };

      const sendMessage = async (text) => {
        const response = await fetch('/api/chat', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ text, sessionKey: config.sessionKey })
        });
        if (!response.ok) {
          const body = await response.text().catch(() => '');
          throw new Error(`Chat error ${response.status}: ${body || 'no body'}`);
        }
        let data;
        try {
          data = await response.json();
        } catch (err) {
          throw new Error(`Chat parse error: ${String(err)}`);
        }
        return data.text || '';
      };

      const prefetchTts = async (text) => {
        if (!text || ttsLoading) return;
        ttsLoading = true;
        try {
          const response = await fetch('/api/tts', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ text, voice: config.voice })
          });
          if (!response.ok) {
            const body = await response.text().catch(() => '');
            throw new Error(`TTS error ${response.status}: ${body || 'no body'}`);
          }
          const blob = await response.blob();
          if (lastReplyAudioUrl) URL.revokeObjectURL(lastReplyAudioUrl);
          lastReplyAudioUrl = URL.createObjectURL(blob);
          lastReplyAudio = new Audio(lastReplyAudioUrl);
          lastReplyAudio.onended = () => { if (running) setStatus('listening'); };
          lastReplyAudio.onerror = () => { if (running) setStatus('listening', 'TTS playback failed'); };
          if (playBtn) playBtn.disabled = false;
          if (running) setStatus('listening', 'Tap Play to hear reply');
        } catch (err) {
          console.error('TTS fetch failed', err);
          setStatus('error', err?.message || String(err));
        } finally {
          ttsLoading = false;
        }
      };

      const unlockAudio = async () => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = ctx.createBuffer(1,1,22050);
        const source = ctx.createBufferSource();
        source.buffer = buffer; source.connect(ctx.destination); source.start(0);
        if (ctx.state === 'suspended') await ctx.resume();
      };

      const processAudio = async (audioSamples) => {
        try {
          const wavBlob = float32ToWav(audioSamples);
          const transcript = (await transcribe(wavBlob)).trim();
          if (!transcript) return;
          addMessage('user', transcript);
          const reply = await sendMessage(transcript);
          if (reply) {
            updateAssistant(reply);
            lastReplyText = reply;
            if (playBtn) playBtn.disabled = true;
            setStatus('listening', 'Loading audio‚Ä¶');
            prefetchTts(reply);
          }
          currentAssistantEl = null;
        } catch (error) {
          console.error('Processing error:', error);
          setStatus('error', error?.message || String(error) || 'Processing error');
        }
      };

      const startVAD = async () => {
        vadInstance = await vad.MicVAD.new({
          onSpeechStart: () => { if (currentAudio) { currentAudio.pause(); currentAudio = null; } setStatus('recording'); },
          onSpeechEnd: async (audio) => {
            if (busy || !running) return;
            busy = true; setStatus('processing');
            await processAudio(audio);
            busy = false;
            if (running && status !== 'speaking') setStatus('listening');
          },
          onnxWASMBasePath:'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.22.0/dist/',
          baseAssetPath:'https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.29/dist/'
        });
        vadInstance.start();
      };

      const start = async () => {
        if (running) return;
        const ok = await ensureConfig();
        if (!ok) return;
        running = true; startBtn.disabled = true; stopBtn.disabled = false;
        await unlockAudio(); await startVAD(); setStatus('listening');
      };
      const stop = () => {
        running = false;
        if (vadInstance) { vadInstance.pause(); vadInstance = null; }
        if (currentAudio) { currentAudio.pause(); currentAudio = null; }
        setStatus('stopped'); startBtn.disabled = false; stopBtn.disabled = true;
      };

      startBtn.addEventListener('click', start);
      stopBtn.addEventListener('click', stop);
      if (playBtn) {
        playBtn.addEventListener('click', async () => {
          if (!lastReplyText) return;
          if (!lastReplyAudio) {
            setStatus('listening', 'Loading audio‚Ä¶');
            await prefetchTts(lastReplyText);
            setStatus('listening', 'Tap Play to hear reply');
            return;
          }
          try {
            await lastReplyAudio.play();
          } catch (err) {
            console.error('Audio play blocked', err);
            setStatus('listening', 'Tap Play again to enable audio');
          }
        });
      }
      configBtn.addEventListener('click', () => { loadConfig(); fillConfigForm(); configDialog.showModal(); });
      cancelConfig.addEventListener('click', () => configDialog.close());
      configForm.addEventListener('submit', (e) => {
        e.preventDefault();
        applyFormToConfig();
        saveConfig();
        configDialog.close();
      });

      loadConfig();
      setStatus('stopped');
    })();
  </script>
</body>
</html>
